% ch5.tex
% Dieses Werk ist unter einem Creative Commons Namensnennung-Keine kommerzielle Nutzung-Weitergabe
% unter gleichen Bedingungen 3.0 Deutschland Lizenzvertrag lizenziert. Um die Lizenz anzusehen, gehen Sie bitte
% zu http://creativecommons.org/licenses/by-nc-sa/3.0/de/ oder schicken Sie einen Brief an
% Creative Commons, 171 Second Street, Suite 300, San Francisco, California 94105, USA.


%\chapter{Again and again}\label{ch:againandagain}
\chapter{Immer wieder}\label{ch:againandagain}

%There's nothing worse than having to do the same thing over and over and over again.  There's a reason your parents tell you to count sheep to try to go to sleep, and it has got nothing to do with the amazing sleep-inducing powers of woolly mammals.  It's all to do with the fact that endlessly repeating something is boring, and your mind should drop off to sleep more easily, if it's not focussing on something interesting.
Es gibt nichts schlimmeres als immer die gleiche Arbeit zu machen. Das ist der Grund, warum dir deine Eltern sagen, du solltest Schafe zählen, wenn du einschlafen willst. Es hat nichts mit einer geheimnisvollen schläfrigmachenden Eigenschaft dieser wolligen Säugetiere zu tun, sondern das dein Gehirn das endlose wiederholen langweilig findet und leichter einschläft.
\par
%Programmers don't particularly like repeating themselves either. It puts them to sleep as well.  Which is a good reason why all programming languages have what is called a \textbf{for-loop}\index{for-loop}. For example, to print hello 5 times in Python, you \emph{could} do the following:
Programmierer mögen sich auch nicht gerne wiederholen. Davon werden sie auch sehr müde. Darum haben alle Programmiersprachen eine sogenannte \textbf{for-Schleife}\index{for-Schleife}. Wenn du zum Beispiel fünf mal `hallo' ausgeben willst, \emph{könntest} du folgendes schreiben:

%\begin{listing}
%\begin{verbatim}
%>>> print("hello")
%hello
%>>> print("hello")
%hello
%>>> print("hello")
%hello
%>>> print("hello")
%hello
%>>> print("hello")
%hello
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> print("hallo")
hallo
>>> print("hallo")
hallo
>>> print("hallo")
hallo
>>> print("hallo")
hallo
>>> print("hallo")
hallo
\end{Verbatim}

%Which is$\ldots$ rather tedious.
Und das ist$\ldots$ ziemlich mühsam.

%Or you could use a for-loop (note: there's 4 spaces on the second line before the print statement---I've highlighted them using @ so that you can see where they are):
Oder du verwendest die for-Schleife (beachte die 4 Leerzeichen auf der zweiten Zeile---anstatt der Leerzeichen schreibe ich dir das @-Symbol auf, damit du siehst, wo die Leerzeichen sind. Beim abtippen wieder Leerzeichen statt @ verwenden):

%\begin{listingignore}
%\begin{verbatim}
%>>> for x in range(0, 5):
%... @@@@print('hello')
%...
%hello
%hello
%hello
%hello
%hello
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
>>> for x in range(0, 5):
... @@@@print('hallo')
...
hallo
hallo
hallo
hallo
hallo
\end{Verbatim}

%\code{range}\index{functions!range} is a function and is a quick and easy way to create a list of numbers ranging between a start and end number. For example:
Mit der \code{range}\index{Funktion!range} Funktion kannst du schnell und einfach Zahlenlisten erzeugen, die von einer Startnummer anfangen und bei einer Endnummer aufhören. Zum Beispiel:

\begin{Verbatim}[frame=single]
>>> print(list(range(10, 20)))
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
\end{Verbatim}

%So in the case of the for-loop, what the code `\code{for x in range(0, 5)}' is actually telling Python, is to create a list of numbers (0, 1, 2, 3, 4) and then for each number, store the value in the variable \code{x}. We can then use the x in our print statement if we want to:
Bei unserem Beispiel mit der for-Schleife `\code{for x in range(0, 5)}' erzeugt Python eigentlich eine Liste von Zahlen (0, 1, 2, 3, 4) und speichert die Werte in der Variable \code{x}. Wir können die Variable x auch in unserer print Funktion verwenden:

%\begin{listing}
%\begin{verbatim}
%>>> for x in range(0, 5):
%...     print('hello %s' % x)
%hello 0
%hello 1
%hello 2
%hello 3
%hello 4
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> for x in range(0, 5):
...     print('hallo %s' % x)
hallo 0
hallo 1
hallo 2
hallo 3
hallo 4
\end{Verbatim}

%If we get rid of the for-loop again, it might look something like this:
Ohne die for-Schleife würde es ungefähr so aussehen:

%\begin{listing}
%\begin{verbatim}
%x = 0
%print('hello %s' % x)
%x = 1
%print('hello %s' % x)
%x = 2
%print('hello %s' % x)
%x = 3
%print('hello %s' % x)
%x = 4
%print('hello %s' % x)
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
x = 0
print('hallo %s' % x)
x = 1
print('hallo %s' % x)
x = 2
print('hallo %s' % x)
x = 3
print('hallo %s' % x)
x = 4
print('hallo %s' % x)
\end{Verbatim}

%So the loop has actually saved us from writing an extra 8 lines of code.  This is extremely useful, since the average programmer is more lazy than a hippopotamus on a hot day, when it comes to typing. Good programmers hate doing things more than once, so the for-loop is one of the more useful statements in a programming language.
Die Schleife hat uns also das schreiben von 8 Zeilen erspart. Das ist extrem nützlich, weil der durchschnittliche Programmierer wenns ums schreiben geht, fauler ist, als ein Nilpferd an einem heißen Sommertag. Gute Programmierer hassen Dinge mehr als einmal zu machen, also ist die for-Schleife eine sehr nützliche Konstruktion.

%\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
%\subsection*{WARNING!!!}
\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{ACHTUNG!!!}

%If you've been trying out the examples as you go along, you might have got a funny error message when typing in the code for that for-loop.  If you did, it might have looked something like this:
Wenn du das Code Beispiel gerade selber ausprobiert hast, hast du vielleicht eine komische Fehlermeldung bekommen. Vielleicht etwas wie:

\begin{listing}
IndentationError: expected an indented block
\end{listing}

%If you see an error like this, then you missed typing the spaces on the second line.  Spaces in Python (either a normal space or a tab) are extremely important.  We'll talk more about this shortly$\ldots$
Wenn du diesen Fehler bekommst, hast du die Leerzeichen auf der zweiten Zeile vergessen. Leerzeichen (normale Leerzeichen oder ein Tabulator) sind in Python extrem wichtig. Das behandeln wir etwas später.
}}}
\linebreak
\par
%We don't have to stick to using \code{range}, we can also use lists we've already created.  Such as the shopping list we created in the last chapter:
Wir müssen auch nicht unbedingt \code{range} verwenden, sondern könnnten auch bereits erstellte Listen aus dem zweiten Kapitel nutzen:

%\begin{listing}
%\begin{verbatim}
%>>> shopping_list = [ 'eggs', 'milk', 'cheese', 'celery', 'peanut butter',
%... 'baking soda' ]
%>>> for i in shopping_list:
%...     print(i)
%eggs
%milk
%cheese
%celery
%peanut butter
%baking soda
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> Einkaufsliste = ['Eier', 'Milch', 'Käse', 'Sellerie', 'Honig', 'Backpulver']
>>> for i in Einkaufsliste:
...     print(i)
...
Eier
Milch
Käse
Sellerie
Honig
Backpulver
\end{Verbatim}

%The above code is a way of saying, ``for each item in the list, store the value in the variable `i' and then print the contents of that variable''.  Again, if we got rid of the for-loop, we'd have to do something like this:
Mit diesem Code-Beispiel sagen wir Python ``speichere jeden Listeneintrag in der Variable `i' und gib den Inhalt der Variable danach aus''. Ohne die for-Schleife müssten wir es so schreiben:

%\begin{listing}
%\begin{verbatim}
%>>> shopping_list = [ 'eggs', 'milk', 'cheese', 'celery', 'peanut butter',
%... 'baking soda' ]
%>>> print(shopping_list[0])
%eggs
%>>> print(shopping_list[1])
%milk
%>>> print(shopping_list[2])
%cheese
%>>> print(shopping_list[3])
%celery
%>>> print(shopping_list[4])
%peanut butter
%>>> print(shopping_list[5])
%baking soda
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> Einkaufsliste = ['Eier', 'Milch', 'Käse', 'Sellerie', 'Honig', 'Backpulver']
>>> print(Einkaufsliste[0])
Eier
>>> print(Einkaufsliste[1])
Milch
>>> print(Einkaufsliste[2])
Käse
>>> print(Einkaufsliste[3])
Sellerie
>>> print(Einkaufsliste[4])
Honig
>>> print(Einkaufsliste[5])
Backpulver
\end{Verbatim}

%So once again, the loop has saved us from a lot of typing.
Die for-Schleife hat uns wieder eine Menge Tippen erspart.

%\section{When is a block not square?}\index{blocks of code}
\section{Wann ist ein Block nicht quadratisch?}\index{blocks of code}

%When it's a block of code.
Wenn es ein Codeblock ist.
\par
\noindent
%So what's a `block of code' then?
Was ist ein `Codeblock' dann?
\par
%A block of code is a set of programming statements you want to group together.  For example, in the for-loop example above, you might want to do more than just print out the items.  Perhaps you'd want to buy each item and then print out what it was.  Supposing we had a function called `buy', you might write code like this:
Ein Codeblock ist eine Gruppierung von Anweisungen. Bei einem for-loop könntest du mehr als nur den Listeneintrag ausgeben wollen. Vielleicht willst du den Eintrag kaufen und dann ausgeben, was das genau war. Nehmen wir an, dass es die Funktion `kaufen' gibt, dann könnten wir das so schreiben:

%\begin{listingignore}
%\begin{verbatim}
%>>> for i in shopping_list:
%...     buy(i)
%...     print(i)
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
>>> for i in Einkaufsliste:
...     kaufen(i)
...     print(i)
\end{Verbatim}

%Don't bother typing that example into the Python console---because we don't have a buy function and you'll get an error message if you do try to run it---but it does demonstrate a simple Python block made up of 2 commands:
Du brauchst das Beispiel jetzt nicht in der Python Konsole ausprobieren---weil wir die kaufen Funktion noch nicht haben und du einen Fehler zurückbekommen würdest---aber es zeigt dir, wie ein Python Block mit 2 Anweisungen ausschaut:

%\begin{listingignore}
%\begin{verbatim}
%buy(i)
%print(i)
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
kaufen(i)
print(i)
\end{Verbatim}

%In Python, white space\index{white space} such as tab (when you press the tab key) and space (when you press the space bar) is \emph{very} important.  Code that is at the same position is grouped together into blocks.
Leerzeichen\index{Leerzeichen} sind in Python sehr wichtig. Leerzeichen kannst du einfügen, indem zu die Leertaste oder die Tabulator-Taste drückst. Code, der an der gleichen Position gruppiert wurde, ergibt einen Codeblock.

%\begin{listing}
%\begin{verbatim}
%	this would be block 1
%	this would be block 1
%	this would be block 1
%	    this would be block 2
%	    this would be block 2
%	    this would be block 2
%	this would still be block 1
%	this would still be block 1
%	    this would be block 3
%	    this would be block 3
%	        this would be block 4
%	        this would be block 4
%	        this would be block 4
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
    das wäre Block 1
    das wäre Block 1
    das wäre Block 1
        das wäre Block 2
        das wäre Block 2
        das wäre Block 2
    das wäre immer noch Block 1
    das wäre immer noch Block 1
        das wäre Block 3
        das wäre Block 3
            das wäre Block 4
            das wäre Block 4
            das wäre Block 4
\end{Verbatim}
%But you must be consistent with your spacing.  For example:
Du musst aber die Leerzeichen einheitlich verwenden. Zum Beispiel:

%\begin{listingignore}
%\begin{verbatim}
%>>> for i in shopping_list:
%...     buy(i)
%...       print(i)
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
>>> for i in Einkaufsliste:
...     kaufen(i)
...       print(i)
\end{Verbatim}

%The second line (\code{function buy(i)}) starts with \textbf{4} spaces.  The third line (print(i)) starts with \textbf{6} spaces.  Let's take another look at that code with visible spaces (using @ again):
Die zweite Zeile (\code{Funktion kaufen(i)}) fängt mit \textbf{4} Leerzeichen an. Die dritte Zeile (print(i)) fängt mit \textbf{6} Leerzeichen an. Schauen wir uns das ganze nochmals an, indem die Leerzeichen durch sichtbare @-Zeichen ersetzt werden.

%\begin{listingignore}
%\begin{verbatim}
%>>> for i in shopping_list:
%... @@@@buy(i)
%... @@@@@@print(i)
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
>>> for i in Einkaufsliste:
... @@@@kaufen(i)
... @@@@@@print(i)
\end{Verbatim}

%This would cause an error.  Once you start using 4 spaces, you need to continue using 4 spaces.  And if you want to put a block \emph{inside} another block, you'll need 8 spaces (2 x 4) at the beginning of the lines for that inner block.
Das würde einen Fehler verursachen. Wenn du einmal mit 4 Leerzeichen angefangen hast, dann musst du auch mit 4 Leerzeichen weitermachen. Und wenn du einen Block in einen anderer Block \emph{verschachteln} willst, dann brauchst du 8 Leerzeichen (2 x 4) am Anfang des inneren Blocks.
\par
%So the first block has 4 spaces (I'll highlight them again so you can see them):
Der erste Block hat also 4 Leerzeichen (ich markiere sie wieder, damit du sie sehen kannst):

%\begin{listing}
%\begin{verbatim}
%@@@@here's my first block
%@@@@here's my first block
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
@@@@das ist mein erster Block
@@@@das ist mein erster Block
\end{Verbatim}

%And then the second block (which is `inside' the first) needs 8 spaces:
Der zweite Block (der `innerhalb' des ersten ist) braucht 8 Leerzeichen:

%\begin{listing}
%\begin{verbatim}
%@@@@here's my first block
%@@@@here's my first block
%@@@@@@@@here's my second block
%@@@@@@@@here's my second block
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
@@@@das ist mein erster Block
@@@@das ist mein erster Block
@@@@@@@@das ist mein zweiter Block
@@@@@@@@das ist mein zweiter Block
\end{Verbatim}

%Why do we want to put one block `inside' another?  Usually we do this when the second block relies on the first in some way.  Such as our for-loop.  If the line with the for-loop is the first block, then the statements we want to run over and over again are in the second block---in a way they rely on the first block to work properly.
Warum werden Blöcke `ineinander' verschachtelt? Normalerweise dann, wenn der zweite Block vom ersten Block abhängt. Wenn die for-Schleife der erste Block ist, dann sind die Anweisungen, die immer wieder ausgeführt werden, der zweite Block---somit braucht der zweite Block den ersten Block um richtig zu funktionieren.

%In the Python console, once you start typing code in a block, Python continues that block until you press the Enter key on a blank line (you'll see the 3 dots at the beginning of the line showing that you're still inside a block.
Wenn du in der Python Konsole Code in einem Block schreibst, bleibt Python solange in diesem Block, bis du die Enter Taste auf einer leeren Zeile drückst (solange du im Block bist, siehst du 3 Punkte am Anfang der Zeile).

%Let's try some real examples.  Open the console and type the following (remember that you need to press the space bar 4 times at the beginning of the print lines):
Lass uns ein echtes Beispiel probieren. Öffne die Konsole und tippe folgendes ein (und drücke am Anfang der print Zeile 4 mal die Leertaste):

%\begin{listing}
%\begin{verbatim}
%>>> mylist = [ 'a', 'b', 'c' ]
%>>> for i in mylist:
%...     print(i)
%...     print(i)
%...
%a
%a
%b
%b
%c
%c
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> meine_liste = [ 'a', 'b', 'c' ]
>>> for i in meine_liste:
...     print(i)
...     print(i)
...
a
a
b
b
c
c
\end{Verbatim}

%After the second print, press the Enter key on the blank line---which tells the console you want to end the block. It will then print each item in the list twice.
Drücke nach dem zweiten print Befehl zwei mal die Enter Taste---damit sagst du der Python Konsole, dass du den Block beendest. Danach wird jedes Element der Liste zwei mal ausgegeben.
\par
\noindent
%The next example will cause an error message to be displayed:
Das folgende Beispiel wird nicht funktionieren und ein Fehler wird angezeigt werden:

%\begin{listing}
%\begin{verbatim}
%>>> mylist = [ 'a', 'b', 'c' ]
%>>> for i in mylist:
%...     print(i)
%...       print(i)
%...
%File “<stdin>”, line 3
%  print(i)
%  ^
%IndentationError: unexpected indent
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> meine_liste = [ 'a', 'b', 'c' ]
>>> for i in meine_liste:
...     print(i)
...       print(i)
...
  File "<stdin>", line 3
    print(i)
    ^
IndentationError: unexpected indent
\end{Verbatim}

%The second print line has 6 spaces, not 4, which Python doesn't like because it wants spacing to stay the same.
Die zweite print Zeile hat 6 Leerzeichen und nicht 4, was Python nicht mag, weil die Abstände immer gleich bleiben müssen.

%\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
%\subsection*{REMEMBER}
\fbox{\colorbox{PaleBlue}{\parbox{.75\linewidth} {
\subsection*{MERKE DIR}

%If you start your blocks of code with 4 spaces you must continue using 4 spaces.  If you start blocks with 2 spaces, you must continue with 2 spaces.  Stick to 4 spaces, because that's what most people use.
Wenn du deine Blöcke mit 4 Leerzeichen beginnst, musst du mit 4 Leerzeichen weitermachen. Wenn du mit 2 Leerzeichen beginnst, mache mit 2 Leerzeichen weiter. Am besten aber du hältst dich an 4 Leerzeichen, weil das die meisten Leute so verwenden.

}}}

\par
%Here's a more complicated example with 2 blocks of code:
Hier ist ein etwas komplizierteres Beispiel mit 2 Codeblöcken:

%\begin{listing}
%\begin{verbatim}
%>>> mylist = [ 'a', 'b', 'c' ]
%>>> for i in mylist:
%...     print(i)
%...     for j in mylist:
%...         print(j)
%...
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> meine_liste = [ 'a', 'b', 'c' ]
>>> for i in meine_liste:
...     print(i)
...     for j in meine_liste:
...         print(j)
...
\end{Verbatim}

\noindent
%Where are the blocks in this code and what is it going to do...?
Wo sind in diesem Code die Blöcke und was werden sie machen...?
\par
\noindent
%There are \textbf{two} blocks---number one is part of the first for-loop:
Hier gibt es \textbf{zwei} Blöcke---der erste Block gehört zur ersten for-Schleife:

%\begin{listing}
%\begin{verbatim}
%>>> mylist = [ 'a', 'b', 'c' ]
%>>> for i in mylist:
%...     print(i)                #
%...     for j in mylist:        #-- these lines are the FIRST block
%...         print(j)            #
%...
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> meine_liste = [ 'a', 'b', 'c' ]
>>> for i in meine_liste:
...     print(i)                #
...     for j in meine_liste    #-- diese Zeilen sind der ERSTE Block
...         print(j)            #
...
\end{Verbatim}


%Block number two is the single print line in the second for-loop:
Der zweite Block ist die print Zeile der zweiten for-Schleife:

%\begin{listing}
%\begin{verbatim}
%>>> mylist = [ 'a', 'b', 'c' ]
%>>> for i in mylist:
%...     print(i)
%...     for j in mylist:
%...         print(j)               # this line is the SECOND block
%...
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> meine_liste = [ 'a', 'b', 'c' ]
>>> for i in meine_liste:
...     print(i)
...     for j in meine_liste
...         print(j)            # diese Zeile ist der ZWEITE Block
...
\end{Verbatim}

%Can you figure out what this little bit of code is going to do?
Kannst du vorhersagen, was dieses kleine Codebeispiel machen wird?
\par
%It's going to print out the 3 letters from `mylist', but how many times?  If we look at each line, we can probably figure out the number. We know that the first loop statement will go through each of the items in the list, and then run the commands in block number 1. So it will print out a letter, then start the next loop. This loop will also go through each of the items in the list and then run the command in block number 2.  So what we should get when this code runs, is `a' followed by `a', `b', `c', then `b' followed by `a', `b', `c' and so on. Enter the code into the Python console and see for yourself:
Es werden die drei Buchstaben von `meine\_liste' ausgeben. Aber wie oft? Wenn du dir die Zeilen genau anschaust, kannst du es vielleicht sehen. Die for-Schleife wird durch alle Elemente der Liste gehen und dann die Kommandos aus Block 1 ausführen. Nachdem also der erste Buchstabe ausgegeben wird, kommt die nächste for-Schleife dran. In dieser Schleife geht Python wieder alle Elemente durch und führt den Befehl im zweiten Block aus. Also sollten wir den Buchstaben `a' bekommen, gefolgt von `a', `b', `c' dann `b' gefolgt von `a', `b', `c' und so weiter. Gib den Code in die Python Konsole ein und überzeuge dich selbst:

%\begin{listing}
%\begin{verbatim}
%>>> mylist = [ 'a', 'b', 'c' ]
%>>> for i in mylist:
%...     print(i)
%...     for j in mylist:
%...         print(j)
%...
%a
%a
%b
%c
%b
%a
%b
%c
%c
%a
%b
%c
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> meine_liste = [ 'a', 'b', 'c' ]
>>> for i in meine_liste:
...     print(i)
...     for j in meine_liste:
...         print(j)
...
a
a
b
c
b
a
b
c
c
a
b
c
\end{Verbatim}


%How about something more useful than just printing letters?  Remember that calculation we came up with at the beginning of this book to work out how much you might have saved at the end of the year, if you earned \$5 doing chores, \$30 doing a paper route and spent \$10 a week?
Wie wäre es mit etwas anderem als nur Buchstaben auszugeben? Erinnerst du dich noch an die Rechnung am Anfang des Buches als wir berechnet haben, wieviel du in einem Jahr verdienen kannst, wenn du \EUR{5} für die Hausarbeit, \EUR{30} fürs Zeitung austragen bekommst und \EUR{10} pro Woche ausgibst?
\par
\noindent
%It looked like this:
Das hat so ausgesehen:

\begin{Verbatim}[frame=single]
>>> (5 + 30 - 10) * 52
\end{Verbatim}

\noindent
%(That's \$5 + \$30 - \$10 multiplied by 52 weeks in the year).
(Das sind \EUR{5} + \EUR{30} - \EUR{10} multipliziert mit 52 Wochen im Jahr).

%It might be useful to see how much your savings are increasing during the year, rather than working out what they will be at the very end.  We can do this with another for-loop.  But first of all, we need to load those numbers into variables:
Es könnte praktisch sein zu sehen, wie dein Erspartes über das Jahr hinaus ansteigt. Das machen wir mit einer for-Schleife. Zuerst aber laden wir die wichtigen Zahlen in Variablen.

%\begin{listing}
%\begin{verbatim}
%>>> chores = 5
%>>> paper = 30
%>>> spending = 10
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> hausarbeit = 5
>>> zeitung = 30
>>> ausgaben = 10
\end{Verbatim}

%We can perform the original calculation using the variables:
Die Rechnung können wir nun auch mit den Variablen durchführen:

%\begin{listing}
%\begin{verbatim}
%>>> (chores + paper - spending) * 52
%1300
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> (hausarbeit + zeitung - ausgaben) * 52
1300
\end{Verbatim}

%Or we can see the savings increase over the year, by creating another variable called savings, and then using a loop:
Oder wir lassen uns für jede Woche im Jahr den zusammengesparten Betrag ausrechnen, indem wir die neue Variable `erspartes' in einer for-Schleife verwenden:

%\begin{listing}
%\begin{verbatim}
%1. >>> savings = 0
%2. >>> for week in range(1, 53):
%3. ...     savings = savings + chores + paper - spending
%4. ...     print('Week %s = %s' % (week, savings))
%5. ...
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
1. >>> erspartes = 0
2. >>> for woche in range(1, 53):
3. ...     erspartes = erspartes + hausarbeit + zeitung - ausgaben
4. ...     print('%s Woche = %s' % (woche, erspartes))
5. ...
\end{Verbatim}

%On line 1 the variable `savings' is loaded with 0 (because we haven't saved anything yet).\\
In der ersten Zeile setzen wir die Variable `erspartes' auf 0 (am Anfang des Jahres haben wir noch nichts gespart).\\
%Line 2 sets up the for-loop, which will run the commands in the block (the block is made up of lines 3 and 4).  Each time it loops, the variable week is loaded with the next number in the range 1-52.\\
Auf Linie 2 beginnen wir die for-Schleife, die den Block auf Zeile 3 und 4 immer wieder ausführen wird. Bei jedem Durchlauf des Blocks hat die Variable woche eine höhere Zahl.\\
%Line 3 is a bit more complicated.  Basically, each week we want to add what we've saved to our total savings.  Think of the variable `savings' as something like a bank.  We add up the money we earn doing odd jobs and the paper route, subtract our spending money and then take the rest to the bank.  So in computer-speak, line 3 really means, ``replace the contents of the variable savings with my current savings, plus what I've earned this week''. Basically, the equals symbol (=) is a bossy piece of code that is a way of saying, ``work out some stuff on the right first and then save it for later, using the name on the left''.\\
Zeile 3 musst du dir vielleich ein wenig länger anschauen. Denke dir dabei vielleicht die Variable `erspartes' wie eine Sparbüchse. Jede Woche gibtst du das Geld von der Hausarbeit und dem Zeitung austragen hinein. Gleichzeitig nimmst du aber auch \EUR{10} heraus. Der Computer rechnet den Teil rechts vom Gleichheitszeichen (=) zuerst aus und speichert das Ergebnis zur Variable auf der linken Seite.\\
%Line 4 is a slightly more complicated print statement, which prints the week number and the total amount saved (for that week) to the screen.  Check the section \emph{Tricks with Strings} on page~\pageref{trickswithstrings}, if this line doesn't make a lot of sense to you. So, if you run this program, you'll see something like the following$\ldots$
In Zeile 4 ist ein print Befehl, der gleichzeitig die Woche sowie den gesammelten Geldbetrag ausgibt. Schau nochmals auf Seite~\pageref{trickswithstrings} nach, wenn es dir nicht gleich klar wird. Nachdem du alle Zeilen eingegeben hast, wird folgendes ausgegeben$\ldots$

%\begin{listing}
%\begin{verbatim}
%Week 1 = 25
%Week 2 = 50
%Week 3 = 75
%Week 4 = 100
%Week 5 = 125
%Week 6 = 150
%Week 7 = 175
%Week 8 = 200
%Week 9 = 225
%Week 10 = 250
%Week 11 = 275
%Week 12 = 300
%Week 13 = 325
%Week 14 = 350
%Week 15 = 375
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
1 Woche = 25
2 Woche = 50
3 Woche = 75
4 Woche = 100
5 Woche = 125
6 Woche = 150
7 Woche = 175
8 Woche = 200
9 Woche = 225
10 Woche = 250
11 Woche = 275
12 Woche = 300
13 Woche = 325
14 Woche = 350
15 Woche = 375
\end{Verbatim}

%$\ldots$going all the way up to week 52.
$\ldots$bis zur Woche 52.

%\section{While we're talking about looping$\ldots$}\index{while-loop}
\section{Wenn wir schon von Schleifen reden$\ldots$}\index{while-Schleife}

%A for-loop isn't the only kind of looping you can do in Python. There's also the while-loop. If a for-loop is a loop where you know exactly when you'll stop running, a while-loop is a loop where you don't necessarily know ahead of time when you'll stop. Imagine a staircase with 20 steps.  You know you can easily climb 20 steps.  That's a for-loop.
Die for-Schleife ist nicht die einzige Art von Schleifen, die du in Python verwenden kannst. Da gibt es auch die while-Schleife. Bei der for-Schleife, weißt du schon im vornhinein, wann die Schleife zu Ende geht. Bei einer while-Schleife weiß man das nicht. Stell dir eine Stiege mit 20 Treppen vor. Du kannst 20 Stufen einfach hochsteigen. Das ist eine for-Schleife.

%\begin{listing}
%\begin{verbatim}
%>>> for step in range(0,20):
%...     print(step)
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> for stufe in range(0,20):
...     print(stufe)
\end{Verbatim}

%Now imagine a staircase going up a mountainside.  You might run out of energy before you reach the top.  Or the weather might turn bad forcing you to stop climbing.  This is a while-loop.
Stelle dir jetzt eine Treppe vor, die auf einen Berg hinaufführt. Du könntest beim hochsteigen müde werden. Oder es kommt ein Wetterumbruch und du drehst um. Das wäre dann eine while-Schleife.

%\begin{listingignore}
%\begin{verbatim}
%>>> step = 0
%>>> while step < 10000:
%...     print(step)
%...     if tired == True:
%...         break
%...     elif badweather == True:
%...         break
%...     else:
%...         step = step + 1
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
>>> stufe = 0
>>> while stufe < 10000:
...     print(stufe)
...     if muede == True:
...         break
...     elif schlechtes_wetter == True:
...         break
...     else:
...         step = step + 1
\end{Verbatim}

%Don't bother running the code sample above, because we haven't bothered to create the variables \code{tired} and \code{badweather}.  But it demonstrates the basics of a while-loop.  \emph{While} the value of variable \code{step} is less than 10000 (step $<$ 10000) the code in the block is executed.  In the block, we print the value of \code{step}, then check whether \code{tired} or \code{badweather} is true.  If \code{tired} is true, then the \code{break} statement stops the code in the loop executing (basically we jump out of the loop to the next line of code immediately following the block).  If \code{badweather} is true, we also break out of the loop.  If not, then \textbf{1} is added to the value of \code{step}, and the condition of the while loop (step $<$ 10000) is checked again.
Den obigen Code kannst du noch nicht ausprobieren solange die Variablen \code{muede} oder \code{schlechtes\_wetter} nicht existieren. Aber es zeigt dir die Grundlagen einer while-Schleife. Solange die Variable \code{stufe} kleiner als 10000 ist, wird der Inhalt des Blocks ausgeführt. Im Block selber wird der Wert der Variable stufe ausgegeben, danach wird überprüft, ob die Variable \code{muede} oder \code{schlechtes\_wetter} wahr ist. Wenn \code{muede} wahr ist, dann verlässt Python den Block und macht außerhalb weiter. Wenn \code{schlechtes\_wetter} wahr ist genauso. In entgegengesetzten Fall wird \textbf{1} zur Variable \code{stufe} dazugezählt und die Bedingung am Anfang der Schleife wird wieder überprüft.
\par
\noindent
%So the steps of a while loop are basically:
Die Schritte einer while-Schleife sind zusammengefasst:

%{\renewcommand{\labelitemi}{$\triangleright$}
%\begin{itemize}
%\item check the condition,
%\item execute the code in the block,
%\item repeat
%\end{itemize}}
{\renewcommand{\labelitemi}{$\triangleright$}
\begin{itemize}
\item überprüfe die Bedingung,
\item führe den Block aus,
\item wiederhole von vorne
\end{itemize}}

%More commonly, a while-loop might be created with a couple of conditions:
Sehr häufig wird eine while-Schleife mit mehreren Bedingungen verwendet:

\begin{Verbatim}[frame=single]
>>> x = 45
>>> y = 80
>>> while x < 50 and y < 100:
...     x = x + 1
...     y = y + 1
...     print(x, y)
\end{Verbatim}

%In this loop, we create a variable \code{x} with the value 45, and a variable \code{y} with the value 80.  There are two conditions that are checked by the loop: whether \code{x} is less than 50 and whether \code{y} is less than 100. While both conditions are true, the block of code is executed, adding 1 to both variables and then printing them. The output of this code is just:
In dieser Schleife erzeugen wir die Variable \code{x} mit dem Wert 45 und die Variable \code{y} mit dem Wert 80. Es sind zwei Bedingungen, die in der Schleife überprüft werden: ob \code{x} kleiner als 50 ist, oder \code{y} kleiner als 100 ist. Wenn beide Bedingungen wahr sind, dann wird der Codeblock ausgeführt, in dem jeweils die Zahl 1 zu den Variablen hinzugefügt wird und die Variablen ausgegeben. Die Ausgabe des Codes wird folgende sein:

\begin{Verbatim}[frame=single]
46 81
47 82
48 83
49 84
50 85
\end{Verbatim}

%Maybe you can figure out why these numbers are printed?\footnote{We start counting at 45 in the variable \code{x} and at 80 in the variable \code{y}, and then increment (add one) to each variable every time the code in the loop is run.  The conditions check that \code{x} must be less than 50 and \code{y} must be less than 100.  After looping five times (adding 1 to each variable) the value in x reaches 50.  Now the first condition (x $<$ 50) is no longer true, so Python knows to stop looping.}
Vielleich kannst du herausfinden, warum diese Nummern ausgegeben werden?\footnote{Wir beginnen mit \code{x} bei 45 zu zählen und \code{y} fängt bei 80 an. Bei jedem Schleifendurchlauf werden die Zahlen um 1 erhöht. Die Bedingung am Anfang schaut darauf, dass \code{x} kleiner als 50 und \code{y} kleiner als 100 ist. Nach 5 Durchläufen erreicht die Variable \code{x} den Wert 50. Nun ist die erste Bedingung (x $<$ 50) nicht mehr wahr und Python verlässt die Schleife.}

%Another common usage of a while-loop, is to create a semi-eternal loop. This is a loop that basically goes forever, or at least until something happens in the code to break out of it. For example:
Gerne wird die while-Schleife auch für halb-unendliche Schleifen verwendet. Das ist eine Schleife, die eigentlich unendlich läuft, bis irgendwas im code passiert. Zum Beispiel:

%\begin{listingignore}
%\begin{verbatim}
%>>> while True:
%...     lots of code here
%...     lots of code here
%...     lots of code here
%...     if some_condition == True:
%...         break
%\end{verbatim}
%\end{listingignore}
\begin{Verbatim}[frame=single]
>>> while True:
...     hier steht eine Menge Code
...     hier steht eine Menge Code
...     hier steht eine Menge Code
...     if eine_bedingung == True:
...         break
\end{Verbatim}
%The condition for the while loop is just `True'.  So it will always run the code in the block (thus the loop is eternal or infinite). Only if the variable some\_condition is true will the code break out of the loop.  You can see a better example of this in Appendix~\ref{app:afewpythonmodules} (the section about the \code{random} module), but you might want to wait until you've read the next chapter before taking a look at it.
Die Bedingung für die while-Schleife ist `True' (also Wahr). Deswegen wird der nachfolgende Block auch immer ausgeführt (dies erzeugt eine sogenannte Endlosschleife). Erst wenn die Bedingung \code{eine\_bedingung} True (Wahr) wird, verlässt Python die Schleife. Ein schönes Beispiel kannst du im Anhang~\ref{app:afewpythonmodules} sehen (im Abschnitt über das \code{random} Modul), aber vielleicht liest du noch das nächste Kapitel, bevor zu im Anhang nachblätterst.


%\section{Things to try}
\section{Dinge zum Ausprobieren}

%\emph{In this chapter we saw how to use loops to perform repetitive tasks.  We used blocks of code inside the loops for the tasks to be repeated.}
\emph{In diesem Kapitel haben wir gesehen wie man Schleifen für sich wiederholende Aufgaben verwendet. Wir haben Code Blöcke innerhalb von Schleifen verwendet um die Anweisungen zu Gruppieren, die wiederholt werden sollen.}

%\subsection*{Exercise 1}
\subsection*{Übung 1}
%What do you think will happen with the following code?
Was wird der folgende Code machen?

%\begin{listing}
%\begin{verbatim}
%>>> for x in range(0, 20):
%...     print('hello %s' % x)
%...     if x < 9:
%...         break
%\end{verbatim}
%\end{listing}
\begin{Verbatim}[frame=single]
>>> for x in range(0, 20):
...     print('Hallo %s' % x)
...     if x < 9:
...         break
\end{Verbatim}



%\subsection*{Exercise 2}
\subsection*{Übung 2}
%When you save money in a bank, you earn interest.  `Interest' is the money the bank pays you for letting them use your money---each year you are paid a small amount of money depending upon how much you've saved.  This payment is usually added back to your savings account at the bank, and it also makes you money$\ldots$ which is a bit confusing, so you might have to ask Mum or Dad to explain.
Wenn du Geld in die Bank bringst, bekommst du Zinsen. `Zinsen' ist der Geldbetrag, den du von der Bank bekommst, damit die Bank dein Geld benutzen kann---jedes Jahr bekommst du so einen kleinen Betrag auf dein Sparbuch zum anderen Geld. Vielleicht fragst du deine Eltern wie das alles funktioniert.
%Interest is calculated using percentages.  If you don't know what a percentage is, don't worry, it's enough to know that if the bank is paying you 1\% (1 percent) interest, you can multiply the monetary amount by the number 0.01 (if your amount is \$1000, then you will do: 1000 * 0.01).  If they're paying you 2\% interest, you can use the number 0.02, and so on.
Jedenfalls berechnet man die Zinsen mit Prozent. Wenn du nicht weißt, was Prozent sind, macht das nichts. Du musst dir nur merken, wenn du 1\% (1 Prozent) Zinsen bekommst, kannst du die Geldsumme mit 0.01 multiplizieren um die Zinsen zu berechnen (bei \EUR{1000} bekommst du also 1000 x 0.01 = \EUR{10}). Bei zwei Prozent Zinsen multiplizierst du mit 0.02 und so weiter.
%If you have \$100 saved in a bank account, and they pay you 3\% interest every year, how much money do you think you will have each year, up to 10 years?  You can write a program using a for-loop to figure it out  (Hint: remember to add the interest to the total).
Wenn du nun \EUR{100} gespart hast, und du bekommst 3\% Zinsen pro Jahr, wie viel Geld wirst du am Ende der nächsten 10 Jahre haben? Du kannst das mit einer for-Schleife berechnen (Tipp: zähle die Zinsen am Ende des Jahres zur Geldsumme dazu).
\newpage
